## ðŸ“… 2025-08-31

- ðŸ”¢ **Problem 1**: [Two Sum](https://leetcode.com/problems/two-sum)  
  - ðŸ’ª **Difficulty**: Easy  
  - ðŸ’¡ **Insight**:  
    This problem highlights a classic use case for hashmaps in optimizing search operations. Instead of using a brute-force nested loop (O(nÂ²)), I used a dictionary to store previously seen values and their indices. For each element, I calculated its complement (`target - num`) and checked if it already exists in the map. If found, the indices form the required pair. This approach brings the time complexity down to O(n), making it highly efficient for large inputs.

  - ðŸ“Œ **Notes**:
    - **Approach**:  
      - Traverse the array while maintaining a hashmap of `{value: index}`.
      - For each number, compute its complement and check if it exists in the hashmap.
      - If it does, return the indices of the current number and its complement.

    - **Code**:
      ```python
      hashmap = {}
      for ind, val in enumerate(nums):
          if target - val in hashmap:
              return [hashmap[target - val], ind]
          hashmap[val] = ind
      ```

    - **Complexity**:
      - Time: O(n) â€” single pass through the array.
      - Space: O(n) â€” storing up to n elements in the hashmap.

    - **Real-world analogy**:  
      Imagine you're shopping with â‚¹100 in your pocket. As you browse items, you mentally calculate how much more you need to hit â‚¹100. If you've already seen an item priced exactly at that remaining amount, you instantly know the pair that fits your budget.  
      The hashmap acts like your mental ledger tracking what you've seen and helping you instantly identify what you need.

    - **Pattern Recognition**:  
      This is a foundational pattern in array problems involving pairwise relationships. It appears in variations like Subarray Sum Equals K, Longest Consecutive Sequence, and frequency-based lookups. Recognizing when to use a hashmap for complement tracking is key to solving these efficiently.

    - **Reflection**:  
      This exercise reinforced the value of trading space for time. More importantly, it helped me internalize the complement lookup pattern, a technique I expect to reuse frequently in upcoming problems. The analogy made the logic intuitive, and the code felt natural once I framed it that way.
